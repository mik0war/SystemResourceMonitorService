# Служба мониторинга системных ресурсов

Разработка службы Windows, которая собирает информацию о системных ресурсах (использование CPU, память, диск, сеть) и сохраняет данные в лог-файл или базу данных для последующего анализа.

## Архитектура программы

Диаграмма классов приложения

![alt-text](https://github.com/mik0war/SystemResourceMonitorService/blob/master/class_diagram.png)

- **ResourceMonitor** - Класс, собирающий всю информацию о ресурсах, которые к нему присоединены
- **Value/ThresholdedValue** - Классы, позволяющие собирать и проверять на превышение порогового значения (если понадобится) значения ресурсов
- **PerformanceCountManager** - Класс, непосредственно получающий сведения о ресурсе
- **AlertService** - Класс, с помощью которого можно отправить уведомление о превышении значения на почту

## Описание основных этапов сбора ресурсов

### Процесс сбора данных о загрузке CPU

1. Инициализация счетчика CPU
   
В методе Init() создаётся объект CPUCounter, который инкапсулирует работу с системным счётчиком производительности PerformanceCounter. Этот счётчик настраивается для сбора данных о загрузке процессора:

```csharp
new PerformanceCounter("Processor", "% Processor Time", "_Total");
"Processor" — категория счётчика.
"% Processor Time" — метрика, отображающая загрузку CPU в процентах.
"_Total" — указывает, что считываются данные по всем ядрам.
```
2. Получение данных
   
Класс CPUCounter реализует метод GetUsage(), который дважды запрашивает данные у счётчика:

```csharp
cpuCounter.NextValue();
Thread.Sleep(1000);
_lastValue = cpuCounter.NextValue();
```

Первый вызов NextValue() подготавливает счётчик к измерению (возвращает некорректное значение).
Второй вызов, после небольшой задержки, возвращает актуальное значение загрузки CPU.

3. Логирование данных
   
Метод GetLogMessage() формирует строку с текущим значением загрузки CPU:

```csharp
public override string GetLogMessage() => $"CPU {_lastValue}%";
```
4. Проверка на превышение порога
   
Класс ThresholdedValue добавляет функционал проверки значения на превышение заданного порога. Метод CheckThereshold() вызывает действие sendAction, если значение превышает порог:

```csharp

if (_lastValue > thresholdValue)
    action.Invoke(thresholdValue, _lastValue);
```

В данном случае, действие включает отправку email-уведомления через AlertService.

5. Интеграция с мониторингом
Объект CPUCounter оборачивается в ThresholdedValue и передаётся в список ресурсов ResourceMonitor:

```csharp
var cpuResource = new IResource.ThresholdedValue(
    manager: new CPUCounter(...),
    threshold: cpuThreshold,
    sendAction: (cpuThreshold, cpu) =>
    {
        string subject = "Оповещение.  Высокая загрузка CPU";
        string body = $"Загрузка CPU превысила порог в {cpuThreshold}%.\n" +
                      $"Текущая загрузка.  {cpu}%.";

        alertService.SendEmail(subject, body);
    }
);
```

6. Цикл мониторинга
   
В методе Main() используется бесконечный цикл для регулярного сбора данных через ResourceMonitor:

```csharp
Копировать код
var logMessage = monitor.GetLogs();
Log.Information(logMessage);
Console.WriteLine($"[Process] {DateTime.Now}. {logMessage}");
await Task.Delay(TimeSpan.FromSeconds(interval), cts.Token);
```
Значения записываются в лог с использованием Serilog и выводятся в консоль.

Таким образом, процесс сбора данных о производительности CPU включает инициализацию, считывание значений, логирование, проверку порогов и уведомление в случае превышения.

### Процесс сбора данных об оперативной памяти (RAM)

1. Инициализация счётчика памяти
В методе `Init()` создаётся объект `RamCounter`, который инкапсулирует работу с системным счётчиком производительности `PerformanceCounter`. Этот счётчик настроен на получение данных о доступной памяти:
```csharp
new PerformanceCounter("Memory", "Available MBytes");
```
- **"Memory"** — категория счётчика.
- **"Available MBytes"** — метрика, отображающая количество доступной памяти в мегабайтах.

2. Получение данных
Класс `RamCounter` реализует метод `GetUsage()`, который запрашивает текущее значение доступной памяти:
```csharp
_lastValue = ramCounter.NextValue();
```
Метод `NextValue()` возвращает текущее количество доступной памяти в мегабайтах.

3. Логирование данных
Метод `GetLogMessage()` формирует строку с текущим значением доступной памяти:
```csharp
public override string GetLogMessage() => $"Память: {_lastValue}MB";
```

4. Проверка на превышение порога
Как и в случае с CPU, класс `ThresholdedValue` для памяти добавляет возможность проверки значения на превышение заданного порога. Метод `CheckThereshold()` проверяет, если доступная память ниже порога, вызывается действие `sendAction`, которое в данном случае отправляет уведомление:
```csharp
if (_lastValue < thresholdValue)
    action.Invoke(thresholdValue, _lastValue);
```
Если значение доступной памяти меньше порога, вызывается метод, который отправляет email-уведомление через `AlertService`:
```csharp
string subject = "Оповещение.  Низкое количество доступной памяти";
string body = $"Доступная память опустилась ниже порога в {memoryThreshold} MB.\n" +
              $"Текущая доступная память.  {memory} MB.";
alertService.SendEmail(subject, body);
```

5. Интеграция с мониторингом
Объект `RamCounter` оборачивается в `ThresholdedValue` и передаётся в список ресурсов `ResourceMonitor`:
```csharp
var memoryResource = new IResource.ThresholdedValue(
    manager: new RamCounter(...),
    threshold: memoryThreshold,
    sendAction: (memoryThreshold, memory) =>
    {
        string subject = "Оповещение.  Низкое количество доступной памяти";
        string body = $"Доступная память опустилась ниже порога в {memoryThreshold} MB.\n" +
                      $"Текущая доступная память.  {memory} MB.";
        alertService.SendEmail(subject, body);
    }
);
```

6. Цикл мониторинга
В методе `Main()` в цикле происходит регулярное выполнение метода `GetLogs()` из `ResourceMonitor`, который вызывает метод `GetResourceValue()` для каждого ресурса. Для памяти это будет `GetUsage()` из `RamCounter`, возвращающее количество доступной памяти:
```csharp
var logMessage = monitor.GetLogs();
Log.Information(logMessage);
Console.WriteLine($"[Process] {DateTime.Now}. {logMessage}");
await Task.Delay(TimeSpan.FromSeconds(interval), cts.Token);
```
Значения записываются в лог и выводятся в консоль.

### Резюме
Процесс сбора данных об оперативной памяти включает:
1. Инициализацию счётчика доступной памяти через `PerformanceCounter`.
2. Запрос текущего значения доступной памяти с помощью метода `NextValue()`.
3. Формирование строки с текущим значением для логирования.
4. Проверку на превышение заданного порога доступной памяти с отправкой уведомления при необходимости.
5. Регулярный мониторинг с логированием значений.

### Процесс сбора данных о диске

1. Инициализация счётчика диска
В методе `Init()` создаётся объект `DiskCounter`, который инкапсулирует работу с системным счётчиком производительности `PerformanceCounter`. Этот счётчик настроен на получение данных о времени, когда диск был активен:
```csharp
new PerformanceCounter("PhysicalDisk", "% Disk Time", "_Total");
```
- **"PhysicalDisk"** — категория счётчика, которая используется для мониторинга состояния физических дисков.
- **"% Disk Time"** — метрика, которая отображает процент времени, в течение которого диск был занят операциями чтения или записи.
- **"_Total"** — указывает, что считываются данные по всем дискам системы.

2. Получение данных
Класс `DiskCounter` реализует метод `GetUsage()`, который дважды запрашивает данные у счётчика:
```csharp
diskCounter.NextValue();
Thread.Sleep(1000);
_lastValue = diskCounter.NextValue();
```
- Первый вызов `NextValue()` подготавливает счётчик к измерению (возвращает некорректное значение).
- Второй вызов, после задержки в 1 секунду (`Thread.Sleep(1000)`), возвращает актуальное значение процента времени, когда диск был занят.

3. Логирование данных
Метод `GetLogMessage()` формирует строку с текущим значением загрузки диска:
```csharp
public override string GetLogMessage() => $"Диск: {_lastValue}%";
```
Этот метод возвращает строку, которая сообщает процент времени, когда диск был занят (например, "Диск: 45.3%").

4. Интеграция с мониторингом
Объект `DiskCounter` создаётся как экземпляр типа `IResource.Value` и добавляется в список ресурсов `ResourceMonitor`. В данном случае, диск не проверяется на пороги, а только собирается и выводится информация:
```csharp
var diskResource = new IResource.Value(
    manager: new DiskCounter(...));
```

5. Цикл мониторинга
В методе `Main()` в бесконечном цикле выполняется метод `GetLogs()` из `ResourceMonitor`, который вызывает метод `GetResourceValue()` для каждого ресурса, включая диск. Для диска это будет `GetUsage()` из `DiskCounter`, возвращающее процент времени, когда диск был занят:
```csharp
var logMessage = monitor.GetLogs();
Log.Information(logMessage);
Console.WriteLine($"[Process] {DateTime.Now}. {logMessage}");
await Task.Delay(TimeSpan.FromSeconds(interval), cts.Token);
```
Значения записываются в лог и выводятся в консоль.

### Резюме
Процесс сбора данных о диске включает:
1. Инициализацию счётчика времени, когда диск занят операциями чтения/записи с использованием `PerformanceCounter`.
2. Запрос актуальных данных о загрузке диска с помощью метода `NextValue()`, который измеряет время активности диска.
3. Формирование строки с результатом для логирования.
4. Регулярный мониторинг с логированием значений, выполняемое в цикле.

В отличие от мониторинга CPU и памяти, диск в этом примере не проверяется на превышение порога, а просто отслеживается его активность в процентах.

### Процесс сбора данных о сети

1. Инициализация счётчика сети
В методе `Init()` создаётся объект `NetworkCounter`, который инкапсулирует работу с системным счётчиком производительности `PerformanceCounter` для мониторинга сетевых интерфейсов. Этот счётчик настроен для сбора данных о скорости передачи данных (как отправленных, так и полученных пакетов) по всем сетевым интерфейсам:
```csharp
new PerformanceCounterCategory("Network Interface");
```
- **"Network Interface"** — категория счётчика, которая используется для мониторинга сетевых интерфейсов.
- Важно отметить, что для каждого интерфейса создаётся отдельный счётчик, который измеряет скорость передачи данных.

2. Получение данных
Класс `NetworkCounter` реализует метод `GetUsage()`, который суммирует скорость передачи данных по всем сетевым интерфейсам. Для каждого интерфейса создаются два счётчика:
- Один для отслеживания отправленных байтов: `"Bytes Sent/sec"`.
- Другой для отслеживания полученных байтов: `"Bytes Received/sec"`.

Процесс получения данных выглядит так:
```csharp
float totalBytesSent = 0;
float totalBytesReceived = 0;

foreach (var nic in networkInterfaces)
{
    using var bytesSentCounter = new PerformanceCounter("Network Interface", "Bytes Sent/sec", nic);
    using var bytesReceivedCounter = new PerformanceCounter("Network Interface", "Bytes Received/sec", nic);
    totalBytesSent += bytesSentCounter.NextValue();
    totalBytesReceived += bytesReceivedCounter.NextValue();
}

_lastValue = totalBytesSent + totalBytesReceived;
```
- Для каждого сетевого интерфейса создаются два счётчика: один для переданных байтов (`Bytes Sent/sec`), другой для полученных байтов (`Bytes Received/sec`).
- Эти счётчики измеряют скорость передачи данных в байтах в секунду.
- В конце метод суммирует данные по всем интерфейсам и сохраняет общий результат в `_lastValue`.

3. Логирование данных
Метод `GetLogMessage()` формирует строку с текущим значением сетевой активности в мегабайтах в секунду (MB/s):
```csharp
public override string GetLogMessage() => $"Сеть:  {_lastValue / 1024 / 1024} MB/s";
```
- Результат измеряется в байтах, но для удобства выводится в мегабайтах в секунду (для этого значение делится на 1024 дважды — сначала для перевода в килобайты, затем для перевода в мегабайты).

4. Интеграция с мониторингом
Объект `NetworkCounter` создаётся как экземпляр типа `IResource.Value` и добавляется в список ресурсов `ResourceMonitor`:
```csharp
var netResource = new IResource.Value(
    manager: new NetworkCounter(...));
```
В отличие от CPU и памяти, для сети не настроено выполнение действий при превышении порога, а только собирается информация о скорости передачи данных.

5. Цикл мониторинга
В методе `Main()` в бесконечном цикле выполняется метод `GetLogs()` из `ResourceMonitor`, который вызывает метод `GetResourceValue()` для каждого ресурса, включая сеть. Для сети это будет метод `GetUsage()` из `NetworkCounter`, возвращающий суммарную активность всех сетевых интерфейсов:
```csharp
var logMessage = monitor.GetLogs();
Log.Information(logMessage);
Console.WriteLine($"[Process] {DateTime.Now}. {logMessage}");
await Task.Delay(TimeSpan.FromSeconds(interval), cts.Token);
```
Значения записываются в лог и выводятся в консоль.

### Резюме
Процесс сбора данных о сети включает:
1. Инициализацию счётчиков для мониторинга всех сетевых интерфейсов через `PerformanceCounterCategory` с метриками "Bytes Sent/sec" и "Bytes Received/sec".
2. Суммирование данных о скорости передачи данных по всем сетевым интерфейсам.
3. Формирование строки с результатом для логирования, которая отображает сетевую активность в мегабайтах в секунду.
4. Регулярный мониторинг и вывод значений с помощью цикла, который периодически собирает данные и выводит их в лог.

Таким образом, процесс мониторинга сети сводится к суммированию скорости передачи данных по всем доступным сетевым интерфейсам и выводе общей активности сети.
